import {
  __commonJS
} from "./chunk-WOOG5QLI.js";

// node_modules/hawk/dist/browser.js
var require_browser = __commonJS({
  "node_modules/hawk/dist/browser.js"(exports, module) {
    var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(c) {
      return typeof c;
    } : function(c) {
      return c && "function" == typeof Symbol && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c;
    };
    var hawk = { internals: {} };
    hawk.client = { header: function(c, d, e) {
      if (!c || "string" != typeof c && "object" !== ("undefined" == typeof c ? "undefined" : _typeof(c)) || !d || "string" != typeof d || !e || "object" !== ("undefined" == typeof e ? "undefined" : _typeof(e))) throw new Error("Invalid argument type");
      var f = e.timestamp || hawk.utils.nowSec(e.localtimeOffsetMsec), g = e.credentials;
      if (!g || !g.id || !g.key || !g.algorithm) throw new Error("Invalid credentials");
      if (-1 === hawk.crypto.algorithms.indexOf(g.algorithm)) throw new Error("Unknown algorithm");
      "string" == typeof c && (c = hawk.utils.parseUri(c));
      var h = { ts: f, nonce: e.nonce || hawk.utils.randomString(6), method: d, resource: c.resource, host: c.host, port: c.port, hash: e.hash, ext: e.ext, app: e.app, dlg: e.dlg };
      !h.hash && (e.payload || "" === e.payload) && (h.hash = hawk.crypto.calculatePayloadHash(e.payload, g.algorithm, e.contentType));
      var i = hawk.crypto.calculateMac("header", g, h), j = null !== h.ext && void 0 !== h.ext && "" !== h.ext, k = 'Hawk id="' + g.id + '", ts="' + h.ts + '", nonce="' + h.nonce + (h.hash ? '", hash="' + h.hash : "") + (j ? '", ext="' + hawk.utils.escapeHeaderAttribute(h.ext) : "") + '", mac="' + i + '"';
      return h.app && (k += ', app="' + h.app + (h.dlg ? '", dlg="' + h.dlg : "") + '"'), { artifacts: h, header: k };
    }, bewit: function(c, d) {
      if (!c || "string" != typeof c || !d || "object" !== ("undefined" == typeof d ? "undefined" : _typeof(d)) || !d.ttlSec) throw new Error("Invalid inputs");
      d.ext = null === d.ext || d.ext === void 0 ? "" : d.ext;
      var e = hawk.utils.nowSec(d.localtimeOffsetMsec), f = d.credentials;
      if (!f || !f.id || !f.key || !f.algorithm) throw new Error("Invalid credentials");
      if (-1 === hawk.crypto.algorithms.indexOf(f.algorithm)) throw new Error("Unknown algorithm");
      c = hawk.utils.parseUri(c);
      var g = e + d.ttlSec, h = hawk.crypto.calculateMac("bewit", f, { ts: g, nonce: "", method: "GET", resource: c.resource, host: c.host, port: c.port, ext: d.ext }), i = f.id + "\\" + g + "\\" + h + "\\" + d.ext;
      return hawk.utils.base64urlEncode(i);
    }, authenticate: function authenticate(c, d, e, f) {
      f = f || {};
      var g = function(d2) {
        return c.headers ? "function" == typeof c.headers.get ? c.headers.get(d2) : c.headers[d2] : c.getResponseHeader ? c.getResponseHeader(d2) : c.getHeader(d2);
      }, h = g("www-authenticate");
      if (h) {
        var n = hawk.utils.parseAuthorizationHeader(h, ["ts", "tsm", "error"]);
        if (!n) return false;
        if (n.ts) {
          var o = hawk.crypto.calculateTsMac(n.ts, d);
          if (o !== n.tsm) return false;
          hawk.utils.setNtpSecOffset(n.ts - Math.floor(Date.now() / 1e3));
        }
      }
      var i = g("server-authorization");
      if (!i && !f.required) return true;
      var j = hawk.utils.parseAuthorizationHeader(i, ["mac", "ext", "hash"]);
      if (!j) return false;
      var k = { ts: e.ts, nonce: e.nonce, method: e.method, resource: e.resource, host: e.host, port: e.port, hash: j.hash, ext: j.ext, app: e.app, dlg: e.dlg }, l = hawk.crypto.calculateMac("response", d, k);
      if (l !== j.mac) return false;
      if (!f.payload && "" !== f.payload) return true;
      if (!j.hash) return false;
      var m = hawk.crypto.calculatePayloadHash(f.payload, d.algorithm, g("content-type"));
      return m === j.hash;
    }, message: function message(c, d, e, f) {
      if (!c || "string" != typeof c || !d || "number" != typeof d || null === e || e === void 0 || "string" != typeof e || !f || "object" !== ("undefined" == typeof f ? "undefined" : _typeof(f))) throw new Error("Invalid inputs");
      var g = f.timestamp || hawk.utils.nowSec(f.localtimeOffsetMsec), h = f.credentials;
      if (!h || !h.id || !h.key || !h.algorithm) throw new Error("Invalid credentials");
      if (-1 === hawk.crypto.algorithms.indexOf(h.algorithm)) throw new Error("Unknown algorithm");
      var i = { ts: g, nonce: f.nonce || hawk.utils.randomString(6), host: c, port: d, hash: hawk.crypto.calculatePayloadHash(e, h.algorithm) }, j = { id: h.id, ts: i.ts, nonce: i.nonce, hash: i.hash, mac: hawk.crypto.calculateMac("message", h, i) };
      return j;
    }, authenticateTimestamp: function authenticateTimestamp(c, d, e) {
      var f = hawk.crypto.calculateTsMac(c.ts, d);
      return !(f !== c.tsm) && (false !== e && hawk.utils.setNtpSecOffset(c.ts - Math.floor(Date.now() / 1e3)), true);
    } }, hawk.crypto = { headerVersion: "1", algorithms: ["sha1", "sha256"], calculateMac: function calculateMac(c, d, e) {
      var f = hawk.crypto.generateNormalizedString(c, e), g = CryptoJS["Hmac" + d.algorithm.toUpperCase()](f, d.key);
      return g.toString(CryptoJS.enc.Base64);
    }, generateNormalizedString: function generateNormalizedString(c, d) {
      var e = "hawk." + hawk.crypto.headerVersion + "." + c + "\n" + d.ts + "\n" + d.nonce + "\n" + (d.method || "").toUpperCase() + "\n" + (d.resource || "") + "\n" + d.host.toLowerCase() + "\n" + d.port + "\n" + (d.hash || "") + "\n";
      return d.ext && (e += d.ext.replace("\\", "\\\\").replace("\n", "\\n")), e += "\n", d.app && (e += d.app + "\n" + (d.dlg || "") + "\n"), e;
    }, calculatePayloadHash: function calculatePayloadHash(c, d, e) {
      var f = CryptoJS.algo[d.toUpperCase()].create();
      return f.update("hawk." + hawk.crypto.headerVersion + ".payload\n"), f.update(hawk.utils.parseContentType(e) + "\n"), f.update(c), f.update("\n"), f.finalize().toString(CryptoJS.enc.Base64);
    }, calculateTsMac: function calculateTsMac(c, d) {
      var e = CryptoJS["Hmac" + d.algorithm.toUpperCase()]("hawk." + hawk.crypto.headerVersion + ".ts\n" + c + "\n", d.key);
      return e.toString(CryptoJS.enc.Base64);
    } }, hawk.internals.LocalStorage = function() {
      this._cache = {}, this.length = 0, this.getItem = function(c) {
        return this._cache.hasOwnProperty(c) ? this._cache[c] + "" : null;
      }, this.setItem = function(c, d) {
        this._cache[c] = d + "", this.length = Object.keys(this._cache).length;
      }, this.removeItem = function(c) {
        delete this._cache[c], this.length = Object.keys(this._cache).length;
      }, this.clear = function() {
        this._cache = {}, this.length = 0;
      }, this.key = function(c) {
        return Object.keys(this._cache)[c || 0];
      };
    }, hawk.utils = { storage: new hawk.internals.LocalStorage(), setStorage: function setStorage(c) {
      var d = hawk.utils.storage.getItem("hawk_ntp_offset");
      hawk.utils.storage = c, d && hawk.utils.setNtpSecOffset(d);
    }, setNtpSecOffset: function setNtpSecOffset(c) {
      try {
        hawk.utils.storage.setItem("hawk_ntp_offset", c);
      } catch (c2) {
        console.error("[hawk] could not write to storage."), console.error(c2);
      }
    }, getNtpSecOffset: function getNtpSecOffset() {
      var c = hawk.utils.storage.getItem("hawk_ntp_offset");
      return c ? parseInt(c, 10) : 0;
    }, now: function now(c) {
      return Date.now() + (c || 0) + 1e3 * hawk.utils.getNtpSecOffset();
    }, nowSec: function nowSec(c) {
      return Math.floor(hawk.utils.now(c) / 1e3);
    }, escapeHeaderAttribute: function escapeHeaderAttribute(c) {
      return c.replace(/\\/g, "\\\\").replace(/\"/g, '\\"');
    }, parseContentType: function parseContentType(c) {
      return c ? c.split(";")[0].replace(/^\s+|\s+$/g, "").toLowerCase() : "";
    }, parseAuthorizationHeader: function parseAuthorizationHeader(c, d) {
      if (!c) return null;
      var e = c.match(/^(\w+)(?:\s+(.*))?$/);
      if (!e) return null;
      var f = e[1];
      if ("hawk" !== f.toLowerCase()) return null;
      var g = e[2];
      if (!g) return null;
      var h = {}, i = g.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, function(c2, e2, f2) {
        if (-1 !== d.indexOf(e2)) return null === f2.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~]+$/) || h.hasOwnProperty(e2) ? void 0 : (h[e2] = f2, "");
      });
      return "" === i ? h : null;
    }, randomString: function randomString(c) {
      for (var d = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", e = d.length, f = [], g = 0; g < c; ++g) f[g] = d[Math.floor(Math.random() * e)];
      return result.join("");
    }, uriRegex: /^([^:]+)\:\/\/(?:[^@/]*@)?([^\/:]+)(?:\:(\d+))?([^#]*)(?:#.*)?$/, parseUri: function parseUri(c) {
      var d = c.match(hawk.utils.uriRegex);
      if (!d) return { host: "", port: "", resource: "" };
      var e = d[1].toLowerCase(), f = { host: d[2], port: d[3] || ("http" === e ? "80" : "https" === e ? "443" : ""), resource: d[4] };
      return f;
    }, base64urlEncode: function base64urlEncode(c) {
      var d = CryptoJS.enc.Utf8.parse(c), e = CryptoJS.enc.Base64.stringify(d);
      return e.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
    } };
    var CryptoJS = CryptoJS || function(i, c) {
      var d = {}, e = d.lib = {}, g = function() {
      }, h = e.Base = { extend: function extend(c2) {
        g.prototype = this;
        var d2 = new g();
        return c2 && d2.mixIn(c2), d2.hasOwnProperty("init") || (d2.init = function() {
          d2.$super.init.apply(this, arguments);
        }), d2.init.prototype = d2, d2.$super = this, d2;
      }, create: function create() {
        var c2 = this.extend();
        return c2.init.apply(c2, arguments), c2;
      }, init: function init() {
      }, mixIn: function mixIn(c2) {
        for (var d2 in c2) c2.hasOwnProperty(d2) && (this[d2] = c2[d2]);
        c2.hasOwnProperty("toString") && (this.toString = c2.toString);
      }, clone: function clone() {
        return this.init.prototype.extend(this);
      } }, k = e.WordArray = h.extend({ init: function init(d2, e2) {
        d2 = this.words = d2 || [], this.sigBytes = e2 == c ? 4 * d2.length : e2;
      }, toString: function toString(c2) {
        return (c2 || j).stringify(this);
      }, concat: function concat(f2) {
        var g2 = this.words, h2 = f2.words, d2 = this.sigBytes;
        if (f2 = f2.sigBytes, this.clamp(), d2 % 4) for (var c2 = 0; c2 < f2; c2++) g2[d2 + c2 >>> 2] |= (255 & h2[c2 >>> 2] >>> 24 - 8 * (c2 % 4)) << 24 - 8 * ((d2 + c2) % 4);
        else if (65535 < h2.length) for (var e2 = 0; e2 < f2; e2 += 4) g2[d2 + e2 >>> 2] = h2[e2 >>> 2];
        else g2.push.apply(g2, h2);
        return this.sigBytes += f2, this;
      }, clamp: function clamp() {
        var c2 = this.words, d2 = this.sigBytes;
        c2[d2 >>> 2] &= 4294967295 << 32 - 8 * (d2 % 4), c2.length = i.ceil(d2 / 4);
      }, clone: function clone() {
        var c2 = h.clone.call(this);
        return c2.words = this.words.slice(0), c2;
      }, random: function random(c2) {
        for (var e2 = [], f2 = 0; f2 < c2; f2 += 4) e2.push(0 | 4294967296 * i.random());
        return new k.init(b, c2);
      } }), f = d.enc = {}, j = f.Hex = { stringify: function stringify(f2) {
        var g2 = f2.words;
        f2 = f2.sigBytes;
        for (var h2, e2 = [], d2 = 0; d2 < f2; d2++) h2 = 255 & g2[d2 >>> 2] >>> 24 - 8 * (d2 % 4), e2.push((h2 >>> 4).toString(16)), e2.push((15 & h2).toString(16));
        return e2.join("");
      }, parse: function parse(e2) {
        for (var f2 = e2.length, g2 = [], d2 = 0; d2 < f2; d2 += 2) g2[d2 >>> 3] |= parseInt(e2.substr(d2, 2), 16) << 24 - 4 * (d2 % 8);
        return new k.init(g2, f2 / 2);
      } }, l = f.Latin1 = { stringify: function stringify(e2) {
        var f2 = e2.words;
        e2 = e2.sigBytes;
        for (var g2 = [], d2 = 0; d2 < e2; d2++) g2.push(String.fromCharCode(255 & f2[d2 >>> 2] >>> 24 - 8 * (d2 % 4)));
        return g2.join("");
      }, parse: function parse(e2) {
        for (var f2 = e2.length, g2 = [], d2 = 0; d2 < f2; d2++) g2[d2 >>> 2] |= (255 & e2.charCodeAt(d2)) << 24 - 8 * (d2 % 4);
        return new k.init(g2, f2);
      } }, m = f.Utf8 = { stringify: function stringify(c2) {
        try {
          return decodeURIComponent(escape(l.stringify(c2)));
        } catch (c3) {
          throw Error("Malformed UTF-8 data");
        }
      }, parse: function parse(c2) {
        return l.parse(unescape(encodeURIComponent(c2)));
      } }, n = e.BufferedBlockAlgorithm = h.extend({ reset: function reset() {
        this._data = new k.init(), this._nDataBytes = 0;
      }, _append: function _append(c2) {
        "string" == typeof c2 && (c2 = m.parse(c2)), this._data.concat(c2), this._nDataBytes += c2.sigBytes;
      }, _process: function _process(h2) {
        var j2 = this._data, l2 = j2.words, d2 = j2.sigBytes, c2 = this.blockSize, e2 = d2 / (4 * c2), e2 = h2 ? i.ceil(e2) : i.max((0 | e2) - this._minBufferSize, 0);
        if (h2 = e2 * c2, d2 = i.min(4 * h2, d2), h2) {
          for (var f2 = 0; f2 < h2; f2 += c2) this._doProcessBlock(l2, f2);
          f2 = l2.splice(0, h2), j2.sigBytes -= d2;
        }
        return new k.init(f2, d2);
      }, clone: function clone() {
        var c2 = h.clone.call(this);
        return c2._data = this._data.clone(), c2;
      }, _minBufferSize: 0 });
      e.Hasher = n.extend({ cfg: h.extend(), init: function init(c2) {
        this.cfg = this.cfg.extend(c2), this.reset();
      }, reset: function reset() {
        n.reset.call(this), this._doReset();
      }, update: function update(c2) {
        return this._append(c2), this._process(), this;
      }, finalize: function finalize(c2) {
        return c2 && this._append(c2), this._doFinalize();
      }, blockSize: 16, _createHelper: function _createHelper(c2) {
        return function(e2, f2) {
          return new c2.init(f2).finalize(e2);
        };
      }, _createHmacHelper: function _createHmacHelper(c2) {
        return function(e2, f2) {
          return new o.HMAC.init(c2, f2).finalize(e2);
        };
      } });
      var o = d.algo = {};
      return d;
    }(Math);
    (function() {
      var c = CryptoJS, e = c.lib, f = e.WordArray, g = e.Hasher, i = [], e = c.algo.SHA1 = g.extend({ _doReset: function _doReset() {
        this._hash = new f.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
      }, _doProcessBlock: function _doProcessBlock(d, k) {
        for (var l = this._hash.words, m = l[0], e2 = l[1], n = l[2], h = l[3], j = l[4], o = 0; 80 > o; o++) {
          if (16 > o) i[o] = 0 | d[k + o];
          else {
            var c2 = i[o - 3] ^ i[o - 8] ^ i[o - 14] ^ i[o - 16];
            i[o] = c2 << 1 | c2 >>> 31;
          }
          c2 = (m << 5 | m >>> 27) + j + i[o], c2 = 20 > o ? c2 + ((e2 & n | ~e2 & h) + 1518500249) : 40 > o ? c2 + ((e2 ^ n ^ h) + 1859775393) : 60 > o ? c2 + ((e2 & n | e2 & h | n & h) - 1894007588) : c2 + ((e2 ^ n ^ h) - 899497514), j = h, h = n, n = e2 << 30 | e2 >>> 2, e2 = m, m = c2;
        }
        l[0] = 0 | l[0] + m, l[1] = 0 | l[1] + e2, l[2] = 0 | l[2] + n, l[3] = 0 | l[3] + h, l[4] = 0 | l[4] + j;
      }, _doFinalize: function _doFinalize() {
        var c2 = this._data, f2 = c2.words, d = 8 * this._nDataBytes, g2 = 8 * c2.sigBytes;
        return f2[g2 >>> 5] |= 128 << 24 - g2 % 32, f2[(g2 + 64 >>> 9 << 4) + 14] = Math.floor(d / 4294967296), f2[(g2 + 64 >>> 9 << 4) + 15] = d, c2.sigBytes = 4 * f2.length, this._process(), this._hash;
      }, clone: function clone() {
        var c2 = g.clone.call(this);
        return c2._hash = this._hash.clone(), c2;
      } });
      c.SHA1 = g._createHelper(e), c.HmacSHA1 = g._createHmacHelper(e);
    })(), function(e) {
      for (var c = CryptoJS, f = c.lib, g = f.WordArray, h = f.Hasher, f = c.algo, i = [], o = [], j = function(c2) {
        return 0 | 4294967296 * (c2 - (0 | c2));
      }, k = 2, l = 0; 64 > l; ) {
        var m;
        a: {
          m = k;
          for (var d = e.sqrt(m), p = 2; p <= d; p++) if (!(m % p)) {
            m = false;
            break a;
          }
          m = true;
        }
        m && (8 > l && (i[l] = j(e.pow(k, 0.5))), o[l] = j(e.pow(k, 1 / 3)), l++), k++;
      }
      var r = [], f = f.SHA256 = h.extend({ _doReset: function _doReset() {
        this._hash = new g.init(i.slice(0));
      }, _doProcessBlock: function _doProcessBlock(i2, n) {
        for (var h2 = this._hash.words, q = h2[0], c2 = h2[1], d2 = h2[2], s = h2[3], k2 = h2[4], t = h2[5], g2 = h2[6], j2 = h2[7], l2 = 0; 64 > l2; l2++) {
          if (16 > l2) r[l2] = 0 | i2[n + l2];
          else {
            var e2 = r[l2 - 15], m2 = r[l2 - 2];
            r[l2] = ((e2 << 25 | e2 >>> 7) ^ (e2 << 14 | e2 >>> 18) ^ e2 >>> 3) + r[l2 - 7] + ((m2 << 15 | m2 >>> 17) ^ (m2 << 13 | m2 >>> 19) ^ m2 >>> 10) + r[l2 - 16];
          }
          e2 = j2 + ((k2 << 26 | k2 >>> 6) ^ (k2 << 21 | k2 >>> 11) ^ (k2 << 7 | k2 >>> 25)) + (k2 & t ^ ~k2 & g2) + o[l2] + r[l2], m2 = ((q << 30 | q >>> 2) ^ (q << 19 | q >>> 13) ^ (q << 10 | q >>> 22)) + (q & c2 ^ q & d2 ^ c2 & d2), j2 = g2, g2 = t, t = k2, k2 = 0 | s + e2, s = d2, d2 = c2, c2 = q, q = 0 | e2 + m2;
        }
        h2[0] = 0 | h2[0] + q, h2[1] = 0 | h2[1] + c2, h2[2] = 0 | h2[2] + d2, h2[3] = 0 | h2[3] + s, h2[4] = 0 | h2[4] + k2, h2[5] = 0 | h2[5] + t, h2[6] = 0 | h2[6] + g2, h2[7] = 0 | h2[7] + j2;
      }, _doFinalize: function _doFinalize() {
        var f2 = this._data, d2 = f2.words, g2 = 8 * this._nDataBytes, h2 = 8 * f2.sigBytes;
        return d2[h2 >>> 5] |= 128 << 24 - h2 % 32, d2[(h2 + 64 >>> 9 << 4) + 14] = e.floor(g2 / 4294967296), d2[(h2 + 64 >>> 9 << 4) + 15] = g2, f2.sigBytes = 4 * d2.length, this._process(), this._hash;
      }, clone: function clone() {
        var c2 = h.clone.call(this);
        return c2._hash = this._hash.clone(), c2;
      } });
      c.SHA256 = h._createHelper(f), c.HmacSHA256 = h._createHmacHelper(f);
    }(Math), function() {
      var d = CryptoJS, i = d.enc.Utf8;
      d.algo.HMAC = d.lib.Base.extend({ init: function init(k, l) {
        k = this._hasher = new k.init(), "string" == typeof l && (l = i.parse(l));
        var m = k.blockSize, c = 4 * m;
        l.sigBytes > c && (l = k.finalize(l)), l.clamp();
        for (var e = this._oKey = l.clone(), f = this._iKey = l.clone(), g = e.words, h = f.words, j = 0; j < m; j++) g[j] ^= 1549556828, h[j] ^= 909522486;
        e.sigBytes = f.sigBytes = c, this.reset();
      }, reset: function reset() {
        var c = this._hasher;
        c.reset(), c.update(this._iKey);
      }, update: function update(c) {
        return this._hasher.update(c), this;
      }, finalize: function finalize(c) {
        var d2 = this._hasher;
        return c = d2.finalize(c), d2.reset(), d2.finalize(this._oKey.clone().concat(c));
      } });
    }(), function() {
      var c = CryptoJS, i = c.lib.WordArray;
      c.enc.Base64 = { stringify: function stringify(h) {
        var i2 = h.words, e = h.sigBytes, f = this._map;
        h.clamp(), h = [];
        for (var c2 = 0; c2 < e; c2 += 3) for (var j = (255 & i2[c2 >>> 2] >>> 24 - 8 * (c2 % 4)) << 16 | (255 & i2[c2 + 1 >>> 2] >>> 24 - 8 * ((c2 + 1) % 4)) << 8 | 255 & i2[c2 + 2 >>> 2] >>> 24 - 8 * ((c2 + 2) % 4), d = 0; 4 > d && c2 + 0.75 * d < e; d++) h.push(f.charAt(63 & j >>> 6 * (3 - d)));
        if (i2 = f.charAt(64)) for (; h.length % 4; ) h.push(i2);
        return h.join("");
      }, parse: function parse(j) {
        var k = j.length, e = this._map, f = e.charAt(64);
        f && (f = j.indexOf(f), -1 != f && (k = f));
        for (var f = [], c2 = 0, l = 0; l < k; l++) if (l % 4) {
          var d = e.indexOf(j.charAt(l - 1)) << 2 * (l % 4), g = e.indexOf(j.charAt(l)) >>> 6 - 2 * (l % 4);
          f[c2 >>> 2] |= (d | g) << 24 - 8 * (c2 % 4), c2++;
        }
        return i.create(f, c2);
      }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" };
    }(), hawk.crypto.utils = CryptoJS, "undefined" != typeof module && module.exports && (module.exports = hawk);
  }
});
export default require_browser();
//# sourceMappingURL=hawk.js.map
